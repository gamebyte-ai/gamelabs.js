# gamelabsjs
`gamelabsjs` is an MVC-ish game framework for fast prototyping.

- Minimal **dependency injection** container (`DIContainer`) with singleton bindings
- **View ↔ controller wiring** via `ViewFactory` (`IView` + `IViewController`)
- Clear separation: **controllers depend on view interfaces**, not concrete rendering code
- **Modules** via `IModuleBinding` (DI + views + assets as a reusable unit)
- Two-layer rendering:
  - **World (3D)**: Three.js (`WorldViewBase`)
  - **HUD / UI**: PixiJS (`HudViewBase`, `ScreenView`)

## Quick start (mirrors the examples)
- Create your app by extending `GamelabsApp`
- Call `await app.initialize()` then `app.mainLoop()`
- Register modules in `registerModules()` and register app-specific DI/views/assets via lifecycle hooks

## App class (`GamelabsApp`)
Your `YourGameApp` extends `GamelabsApp` and typically overrides:
- `registerModules()`: call `this.addModule(...)` to register `IModuleBinding` instances
- `configureDI()`: bind app/services/events into `diContainer` (runs after registered modules configure DI)
- `configureViews()`: register view/controller pairs into `viewFactory` (runs after registered modules configure views)
- `loadAssets()`: enqueue assets in `assetLoader` (runs after registered modules enqueue assets)
- `postInitialize()`: create initial screens/views and hook event subscriptions (called after assets are loaded)
- `onStep(timestepSeconds)`: per-frame logic hook (called after `updateService.tick()`)
- `preDestroy()`: unsubscribe + cleanup owned resources

Notes:
- If you want Pixi + Three to share the same WebGL context, pass `{ sharedContext: true }` to `super(...)`.
- `initialize()` creates `world` + `hud`, sets view containers, runs `registerModules()`, then runs module hooks + app hooks, waits for assets, then calls `postInitialize()`.

## Assets (`AssetLoader`, `AssetRequest`)
Create an assets catalog for your game/module:
- Use `AssetRequest` + `AssetTypes` to describe what to load and where (URLs).
- Call `assetLoader.load(...)` inside `loadAssets()`.

## Config (project constants / tuning)
Keep user-defined values in a config object (transitions, timing, tuning values, limits, etc.).
This keeps controllers lean and avoids magic numbers.

## Events (app/controller communication)
Use events to decouple controllers from each other and from app/model code.

Typical pattern:
- Define event classes (e.g. `GameEvents`, `MainScreenEvents`)
- Bind them into `diContainer` in `configureDI()`
- Controllers resolve them via `resolver.getInstance(...)` and subscribe/unsubscribe as needed

## Views (`IView`, base view classes)
Views are responsible for rendering and user interaction details.

- `IView` lifecycle is wired by `ViewFactory`:
  - `view.initialize(viewFactory, assetLoader)`
  - `view.postInitialize()`
  - `view.setController(controller)`
  - `controller.initialize(view, resolver)`
- Base classes implement the standard wiring fields and default destruction:
  - `WorldViewBase` (Three.js) for world views
  - `HudViewBase` (PixiJS) for HUD views
  - `ScreenView` (PixiJS) for full-screen HUD screens + transitions

Guidelines:
- Expose a **small interface** (e.g. `ICubeView`) for controllers: methods like `setColor()`, `setVisible()`, `playIntro()`, etc.
- Prefer “view creates subviews” (composition) where helpful (see Example01 `GameScreenView` creating `TopBarView`/`DebugBarView`).

## Controllers (`IViewController`)
Controllers orchestrate behavior and app wiring.

- Implement `IViewController<TView>`
- `initialize(view, resolver)` is called after the view is created and wired
- `destroy()` is called when the view is destroyed (base views call `controller.destroy()`)

## Modules (`IModuleBinding`)
Modules are reusable bundles that can register:
- DI bindings: `configureDI(diContainer)`
- View registrations: `configureViews(viewFactory)`
- Assets: `loadAssets(assetLoader)`

Apps compose modules by registering them in `registerModules()`:
- Create/store module bindings as fields (recommended if they hold state/models)
- In `registerModules()`, call `this.addModule(this.someModuleBinding)` in the desired order

`GamelabsApp.initialize()` will then call, in order:
- `module.configureDI(...)` for all modules, then app `configureDI()`
- `module.configureViews(...)` for all modules, then app `configureViews()`
- `module.loadAssets(...)` for all modules, then app `loadAssets()`
