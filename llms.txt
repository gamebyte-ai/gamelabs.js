# gamelabsjs
`gamelabsjs` is a **TypeScript project skeleton + reusable modules** for web games that combine **Three.js (3D world)** and **PixiJS (2D HUD/UI)**.

It is designed primarily for **AI-generated game projects** where **humans review every output**. The point is consistency:

- All projects follow a similar structure so review is fast.
- Rendering/scene management stays separate from game logic.
- Features land as reusable modules so they don’t get re-built for every project.

This is **not** a full engine. It intentionally exposes Three/Pixi directly and provides a small set of opinionated primitives for program flow and wiring.

- Minimal **dependency injection** container (`DIContainer`) with singleton bindings
- **View ↔ controller wiring** via `ViewFactory` (`IView` + `IViewController`)
- Clear separation: **controllers depend on view interfaces**, not concrete rendering code
- **Modules** via `ModuleBinding` (DI + views + assets as a reusable unit)
- Two-layer rendering:
  - **World (3D)**: Three.js (`World`, `WorldViewBase`)
  - **HUD / UI**: PixiJS (`Hud`, `HudViewBase`, `ScreenView`)

## Non-negotiable structure rules (for keeping projects reviewable)
- Put rendering and scene graph code in Views (`WorldViewBase` / `HudViewBase` / `ScreenView`), not in controllers.
- Put behavior/state orchestration in Controllers (and Models), not in views.
- Use Events (in DI) for cross-feature communication; avoid controllers calling each other directly.
- Prefer reusable Modules (`ModuleBinding`) for feature-sized work. If it’s likely to be reused, it should be a module.
- Keep module APIs small and explicit (view contracts as interfaces; events/models in DI; wiring in the module binding).

## Quick start (mirrors the examples)
- Create your app by extending `GamelabsApp`
- Call `await app.initialize()` then `app.mainLoop()`
- Register modules in `registerModules()` and register app-specific DI/views/assets via lifecycle hooks

## App class (`GamelabsApp`)
Your `YourGameApp` extends `GamelabsApp` and typically overrides:
- `registerModules()`: call `this.addModule(...)` to register `ModuleBinding` instances
- `configureDI()`: bind app/services/events into `diContainer` (runs after registered modules configure DI)
- `configureViews()`: register view/controller pairs into `viewFactory` (runs after registered modules configure views)
- `loadAssets()`: enqueue app-specific assets in `assetLoader` (runs after module asset requests are enqueued)
- `postInitialize()`: create initial screens/views and hook event subscriptions (called after assets are loaded)
- `onStep(timestepSeconds)`: per-frame logic hook (called after `updateService.tick()`)
- `preDestroy()`: unsubscribe + cleanup owned resources

Notes:
- If you want Pixi + Three to share the same WebGL context, pass `{ sharedContext: true }` to `super(...)`.
- `initialize()` creates `world` + `hud`, sets view containers, runs `registerModules()`, then runs module hooks + app hooks, waits for assets, then calls `postInitialize()`.

## Assets (`AssetLoader`, `AssetRequest`)
Create an assets catalog for your game/module:
- Use `AssetRequest` + `AssetTypes` to describe what to load and where (URLs).
- App-specific assets: call `assetLoader.load(...)` inside app `loadAssets()`.
- Module assets: store `AssetRequest`s on your `ModuleBinding` (see Modules section). The app will bulk-load them automatically.

Overriding module assets:
- Module bindings can support theming/white-labeling by calling `binding.overrideAssetUrl(assetId, newUrl)` before `addModule(binding)`.

Practical note:
- `gamelabsjs` expects consumers to install peer deps: `three`, `pixi.js`, `@pixi/layout`, `@pixi/ui`.

## Config (project constants / tuning)
Keep user-defined values in a config object (transitions, timing, tuning values, limits, etc.).
This keeps controllers lean and avoids magic numbers.

## Events (app/controller communication)
Use events to decouple controllers from each other and from app/model code.

Typical pattern:
- Define event classes (e.g. `GameEvents`, `MainScreenEvents`)
- Bind them into `diContainer` in `configureDI()`
- Controllers resolve them via `resolver.getInstance(...)` and subscribe/unsubscribe as needed

## Views (`IView`, base view classes)
Views are responsible for rendering and user interaction details.

- `IView` lifecycle is wired by `ViewFactory`:
  - `view.initialize(viewFactory, assetLoader)`
  - `view.postInitialize()`
  - `view.setController(controller)`
  - `controller.initialize(view, resolver)`
- Base classes implement the standard wiring fields and default destruction:
  - `WorldViewBase` (Three.js) for world views
  - `HudViewBase` (PixiJS) for HUD views
  - `ScreenView` (PixiJS) for full-screen HUD screens + transitions

Guidelines:
- Expose a **small interface** (e.g. `ICubeView`) for controllers: methods like `setColor()`, `setVisible()`, `playIntro()`, etc.
- Prefer “view creates subviews” (composition) where helpful (see Example01 `GameScreenView` creating `TopBarView`/`DebugBarView`).

## Controllers (`IViewController`)
Controllers orchestrate behavior and app wiring.

- Implement `IViewController<TView>`
- `initialize(view, resolver)` is called after the view is created and wired
- `destroy()` is called when the view is destroyed (base views call `controller.destroy()`)

## Modules (`ModuleBinding`)
Modules are reusable bundles that can register:
- DI bindings: `configureDI(diContainer)`
- View registrations: `configureViews(viewFactory)`
- Assets: provide `AssetRequest`s via `getAssetRequests()` (internally backed by a protected `_assets` map)

Apps compose modules by registering them in `registerModules()`:
- Create/store module bindings as fields (recommended if they hold state/models)
- In `registerModules()`, call `this.addModule(this.someModuleBinding)` in the desired order

`GamelabsApp.initialize()` will then call, in order:
- `module.configureDI(...)` for all modules, then app `configureDI()`
- `module.configureViews(...)` for all modules, then app `configureViews()`
- `assetLoader.loadAll(module.getAssetRequests())` for all modules, then app `loadAssets()`

## Repository coding constraints (keep diffs predictable)
- Use access modifiers on class members.
- Prefix private/protected fields with `_`.
- Avoid splitting method params/args/imports across multiple lines.
